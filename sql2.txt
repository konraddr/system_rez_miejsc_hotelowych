-- =================================================================
-- 1. CZYSZCZENIE (RESET PEŁNY)
-- =================================================================
DROP VIEW IF EXISTS raport_przychodow CASCADE;

-- Usuwamy stare triggery
DROP TRIGGER IF EXISTS trg_walidacja_dat ON rezerwacje;
DROP TRIGGER IF EXISTS trg_auto_oplacenie ON platnosci;
DROP TRIGGER IF EXISTS trg_sync_platnosci ON rezerwacje;
DROP TRIGGER IF EXISTS trg_loguj_zmiany ON rezerwacje;
DROP TRIGGER IF EXISTS trg_blokada_bezpieczenstwa ON rezerwacje;
DROP TRIGGER IF EXISTS trg_loguj_zmiany_json ON rezerwacje;
DROP TRIGGER IF EXISTS trg_archiwizacja_usera ON uzytkownik;
DROP TRIGGER IF EXISTS trg_ochrona_pokoju ON pokoje;

DROP FUNCTION IF EXISTS waliduj_daty_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS auto_status_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS sync_platnosc_po_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS loguj_zmiane_statusu CASCADE;
DROP FUNCTION IF EXISTS sprawdz_blokade_klienta CASCADE;
DROP FUNCTION IF EXISTS loguj_zmiane_statusu_json CASCADE;
DROP FUNCTION IF EXISTS archiwizuj_przed_usunieciem CASCADE;
DROP FUNCTION IF EXISTS chron_pokoj_przed_usunieciem CASCADE;
DROP FUNCTION IF EXISTS dokonaj_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS symuluj_cene_rezerwacji CASCADE;
DROP FUNCTION IF EXISTS anuluj_rezerwacje_klienta CASCADE;
DROP FUNCTION IF EXISTS utworz_uzytkownika CASCADE;
DROP FUNCTION IF EXISTS zmien_haslo CASCADE;
DROP FUNCTION IF EXISTS usun_pokoj_bezpiecznie CASCADE;

DROP TABLE IF EXISTS logi_systemowe, logi_nosql, platnosci, rezerwacje, pokoje, uzytkownik, archiwum_uzytkownikow, hotele, konfiguracja, progi_zajetosci CASCADE;

-- =================================================================
-- 2. STRUKTURA TABEL
-- =================================================================

CREATE TABLE konfiguracja (
    klucz VARCHAR(50) PRIMARY KEY,
    wartosc NUMERIC(10, 4),
    opis TEXT
);

CREATE TABLE progi_zajetosci (
    id SERIAL PRIMARY KEY,
    procent_od INT,
    procent_do INT,
    mnoznik NUMERIC(4, 2),
    opis VARCHAR(100)
);

CREATE TABLE hotele (
    hotel_id SERIAL PRIMARY KEY,
    nazwa VARCHAR(100),
    miasto VARCHAR(100),
    mnoznik_lato NUMERIC(4, 2) DEFAULT 1.00,
    mnoznik_zima NUMERIC(4, 2) DEFAULT 1.00
);

CREATE TABLE uzytkownik (
    id_uzytkownika SERIAL PRIMARY KEY,
    imie VARCHAR(50),
    nazwisko VARCHAR(50),
    email VARCHAR(100) UNIQUE NOT NULL,
    haslo VARCHAR(100) DEFAULT '1234', 
    nr_tel VARCHAR(20),
    rola VARCHAR(20) DEFAULT 'klient', 
    czy_zablokowany BOOLEAN DEFAULT FALSE,
    manager_hotel_id INTEGER REFERENCES hotele(hotel_id)
);

CREATE TABLE pokoje (
    id_pokoj SERIAL PRIMARY KEY,
    hotel_id INTEGER REFERENCES hotele(hotel_id),
    nr_pokoj VARCHAR(10),
    typ_pokoju VARCHAR(50),
    pojemnosc INTEGER, -- Max dorosłych
    max_dzieci INTEGER DEFAULT 0,
    cena_doba NUMERIC(10, 2)
);

CREATE TABLE rezerwacje (
    id_rezerwacji SERIAL PRIMARY KEY,
    id_uzytkownika INTEGER REFERENCES uzytkownik(id_uzytkownika) ON DELETE CASCADE,
    id_pokoj INTEGER REFERENCES pokoje(id_pokoj),
    rezerwacja_od DATE,
    rezerwacja_do DATE,
    liczba_doroslych INTEGER DEFAULT 1,
    liczba_dzieci INTEGER,
    cena_ostateczna NUMERIC(10, 2), 
    status VARCHAR(20) DEFAULT 'potwierdzona',
    data_utworzenia TIMESTAMP DEFAULT NOW()
);

CREATE TABLE platnosci (
    id_platnosci SERIAL PRIMARY KEY,
    id_rezerwacji INTEGER REFERENCES rezerwacje(id_rezerwacji) ON DELETE CASCADE,
    kwota NUMERIC(10, 2),
    status VARCHAR(20) DEFAULT 'oczekujaca',
    rabat NUMERIC(10, 2) DEFAULT 0
);

-- --- TABELE LOGÓW I ARCHIWUM ---

CREATE TABLE logi_systemowe (
    id_logu SERIAL PRIMARY KEY,
    id_rezerwacji INTEGER,
    stary_status VARCHAR(20),
    nowy_status VARCHAR(20),
    data_zmiany TIMESTAMP DEFAULT NOW(),
    komunikat TEXT
);

CREATE TABLE logi_nosql (
    id SERIAL PRIMARY KEY,
    data_zdarzenia TIMESTAMP DEFAULT NOW(),
    dokument_json JSONB
);

CREATE TABLE archiwum_uzytkownikow (
    id_archiwum SERIAL PRIMARY KEY,
    id_starego_uzytkownika INT,
    email VARCHAR(100),
    data_usuniecia TIMESTAMP DEFAULT NOW(),
    powod TEXT
);

-- =================================================================
-- 3. DANE STARTOWE (SEED)
-- =================================================================

INSERT INTO konfiguracja (klucz, wartosc, opis) VALUES 
('sezon_lato_mnoznik', 1.20, 'Mnożnik lato'),
('sezon_zima_mnoznik', 0.90, 'Mnożnik zima'),
('lojalnosc_prog', 10, 'Rezerwacje do VIP'),
('lojalnosc_rabat', 0.05, 'Rabat VIP'),
('anulowanie_limit_dni', 3, 'Dni na darmowe anulowanie'),
('anulowanie_kara_proc', 0.50, 'Kara za późne anulowanie (50%)');

INSERT INTO progi_zajetosci (procent_od, procent_do, mnoznik, opis) VALUES 
(0, 30, 0.90, 'Promocja -10%'),
(31, 70, 1.00, 'Standard'),
(71, 90, 1.20, 'Wysokie obłożenie'),
(91, 100, 1.50, 'Ostatnie sztuki');

INSERT INTO hotele (nazwa, miasto, mnoznik_lato, mnoznik_zima) VALUES 
('Grand Hotel', 'Warszawa', 1.00, 1.00),
('Morska Bryza', 'Gdańsk', 1.50, 0.80),
('Góralska Chata', 'Zakopane', 1.10, 1.60);

INSERT INTO pokoje (hotel_id, nr_pokoj, typ_pokoju, cena_doba, pojemnosc, max_dzieci) VALUES 
(1, '101', 'Standard', 200, 2, 0),
(1, '201', 'Apartament', 500, 4, 2),
(2, 'G1', 'Widok Morze', 400, 2, 1),
(3, 'Z1', 'Drewniany', 250, 2, 0);

INSERT INTO uzytkownik (imie, nazwisko, email, haslo, rola, manager_hotel_id) VALUES 
('Jan', 'Admin', 'admin@hotel.pl', '1234', 'admin', NULL),
('Anna', 'Klient', 'anna@test.pl', '1234', 'klient', NULL),
('Adam', 'ManagerWaw', 'manager.waw@hotel.pl', '1234', 'manager', 1);

-- =================================================================
-- 4. FUNKCJE (LOGIKA BIZNESOWA)
-- =================================================================

-- F1: Dokonaj Rezerwacji
CREATE OR REPLACE FUNCTION dokonaj_rezerwacji(
    p_uid INT, p_pid INT, p_od DATE, p_do DATE, p_dorosli INT, p_dzieci INT
) RETURNS TEXT AS $$
DECLARE
    v_cena NUMERIC; v_total NUMERIC; v_konflikt INT; v_new_id INT; 
    v_max_osob INT; v_max_dzieci INT;
    v_historia INT; v_rabat NUMERIC := 0; v_msg_info TEXT := ''; v_miesiac INT;
    v_hotel_id INT; v_hotel_lato NUMERIC; v_hotel_zima NUMERIC;
    v_total_pokoje INT; v_zajete_pokoje INT; v_procent_zajetosci INT; 
    v_mnoznik_dyn NUMERIC; v_opis_dyn VARCHAR;
    cfg_prog INT; cfg_rabat_proc NUMERIC;
BEGIN
    LOCK TABLE rezerwacje IN EXCLUSIVE MODE;

    IF p_od < CURRENT_DATE THEN RETURN 'Błąd: Daty wsteczne.'; END IF;
    IF p_do <= p_od THEN RETURN 'Błąd: Zła data wyjazdu.'; END IF;

    SELECT p.cena_doba, p.pojemnosc, p.max_dzieci, h.hotel_id, h.mnoznik_lato, h.mnoznik_zima
    INTO v_cena, v_max_osob, v_max_dzieci, v_hotel_id, v_hotel_lato, v_hotel_zima
    FROM pokoje p JOIN hotele h ON p.hotel_id = h.hotel_id WHERE p.id_pokoj = p_pid;

    -- Walidacja czy dorośli mieszczą się w pokoju
    IF p_dorosli > v_max_osob THEN RETURN 'Błąd: Pokój mieści max ' || v_max_osob || ' dorosłych.'; END IF;
    IF p_dzieci > v_max_dzieci THEN RETURN 'Błąd: Za dużo dzieci (Max ' || v_max_dzieci || ').'; END IF;

    SELECT COUNT(*) INTO v_konflikt FROM rezerwacje 
    WHERE id_pokoj = p_pid AND status NOT LIKE 'anulowana%' 
    AND ((p_od < rezerwacja_do) AND (p_do > rezerwacja_od) OR (p_od = rezerwacja_do) OR (p_do = rezerwacja_od));
    IF v_konflikt > 0 THEN RETURN 'Błąd: Termin zajęty.'; END IF;

    -- Yield Management
    SELECT COUNT(*) INTO v_total_pokoje FROM pokoje WHERE hotel_id = v_hotel_id;
    SELECT COUNT(DISTINCT r.id_pokoj) INTO v_zajete_pokoje 
    FROM rezerwacje r JOIN pokoje p ON r.id_pokoj = p.id_pokoj
    WHERE p.hotel_id = v_hotel_id AND r.status NOT LIKE 'anulowana%'
    AND (r.rezerwacja_od < p_do AND r.rezerwacja_do > p_od);

    IF v_total_pokoje > 0 THEN v_procent_zajetosci := (v_zajete_pokoje::NUMERIC / v_total_pokoje::NUMERIC) * 100;
    ELSE v_procent_zajetosci := 0; END IF;

    SELECT mnoznik, opis INTO v_mnoznik_dyn, v_opis_dyn FROM progi_zajetosci 
    WHERE v_procent_zajetosci BETWEEN procent_od AND procent_do LIMIT 1;
    IF v_mnoznik_dyn IS NOT NULL AND v_mnoznik_dyn != 1.00 THEN 
        v_cena := v_cena * v_mnoznik_dyn; 
    END IF;

    -- Sezonowość
    v_miesiac := EXTRACT(MONTH FROM p_od);
    IF v_miesiac IN (6, 7, 8) AND v_hotel_lato != 1.00 THEN v_cena := v_cena * v_hotel_lato;
    ELSIF v_miesiac IN (1, 2, 12) AND v_hotel_zima != 1.00 THEN v_cena := v_cena * v_hotel_zima; END IF;

    v_total := (p_do - p_od) * v_cena;

    -- Rabat
    SELECT wartosc INTO cfg_prog FROM konfiguracja WHERE klucz='lojalnosc_prog';
    SELECT wartosc INTO cfg_rabat_proc FROM konfiguracja WHERE klucz='lojalnosc_rabat';
    SELECT COUNT(*) INTO v_historia FROM rezerwacje WHERE id_uzytkownika = p_uid AND status NOT LIKE 'anulowana%';
    IF v_historia >= cfg_prog THEN v_rabat := v_total * cfg_rabat_proc; v_total := v_total - v_rabat; END IF;

    INSERT INTO rezerwacje (id_uzytkownika, id_pokoj, rezerwacja_od, rezerwacja_do, liczba_doroslych, liczba_dzieci, cena_ostateczna)
    VALUES (p_uid, p_pid, p_od, p_do, p_dorosli, p_dzieci, v_total) RETURNING id_rezerwacji INTO v_new_id;
    
    INSERT INTO platnosci (id_rezerwacji, kwota, rabat) VALUES (v_new_id, v_total, v_rabat);

    RETURN 'Sukces! Nr: ' || v_new_id || '. Kwota: ' || ROUND(v_total, 2) || ' PLN';
END;
$$ LANGUAGE plpgsql;

-- F2: Symulacja Ceny
CREATE OR REPLACE FUNCTION symuluj_cene_rezerwacji(
    p_uid INT, p_pid INT, p_od DATE, p_do DATE
) RETURNS TEXT AS $$
DECLARE
    v_cena NUMERIC; v_total NUMERIC; v_msg_info TEXT := ''; v_hotel_id INT;
BEGIN
    SELECT p.cena_doba, h.hotel_id INTO v_cena, v_hotel_id
    FROM pokoje p JOIN hotele h ON p.hotel_id = h.hotel_id WHERE p.id_pokoj = p_pid;
    v_total := (p_do - p_od) * v_cena;
    RETURN 'Szacowany koszt: <b>' || ROUND(v_total, 2) || ' PLN</b>';
END;
$$ LANGUAGE plpgsql;

-- F3: Anulowanie
CREATE OR REPLACE FUNCTION anuluj_rezerwacje_klienta(p_id_rez INT, p_id_user INT) RETURNS TEXT AS $$
DECLARE
    v_start DATE; v_stat VARCHAR; v_cena NUMERIC; v_dni INT; v_kara NUMERIC;
    cfg_dni INT; cfg_kara_proc NUMERIC;
BEGIN
    SELECT wartosc INTO cfg_dni FROM konfiguracja WHERE klucz='anulowanie_limit_dni';
    SELECT wartosc INTO cfg_kara_proc FROM konfiguracja WHERE klucz='anulowanie_kara_proc';
    SELECT rezerwacja_od, status, cena_ostateczna INTO v_start, v_stat, v_cena
    FROM rezerwacje WHERE id_rezerwacji = p_id_rez AND id_uzytkownika = p_id_user;
     
    IF v_stat NOT IN ('potwierdzona', 'oczekujaca', 'oplacona') THEN RETURN 'Błąd: Nie można anulować.'; END IF;
    v_dni := v_start - CURRENT_DATE;
     
    IF v_dni >= cfg_dni THEN
        UPDATE rezerwacje SET status = 'anulowana' WHERE id_rezerwacji = p_id_rez;
        UPDATE platnosci SET status = 'zwrocona', kwota = 0 WHERE id_rezerwacji = p_id_rez;
        RETURN 'Anulowano bezkosztowo.';
    ELSE
        v_kara := v_cena * cfg_kara_proc;
        UPDATE rezerwacje SET status = 'anulowana_pozno', cena_ostateczna = ROUND(v_kara, 2) WHERE id_rezerwacji = p_id_rez;
        UPDATE platnosci SET status = 'kara_umowna', kwota = ROUND(v_kara, 2) WHERE id_rezerwacji = p_id_rez;
        RETURN 'Anulowano późno. Kara: ' || ROUND(v_kara, 2) || ' PLN.';
    END IF;
END;
$$ LANGUAGE plpgsql;

-- F4: Utwórz usera
CREATE OR REPLACE FUNCTION utworz_uzytkownika(
    p_imie VARCHAR, p_nazwisko VARCHAR, p_email VARCHAR, p_haslo VARCHAR, p_rola VARCHAR, p_hotel_id INT
) RETURNS TEXT AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM uzytkownik WHERE email = LOWER(p_email)) THEN RETURN 'Email zajęty.'; END IF;
    INSERT INTO uzytkownik (imie, nazwisko, email, haslo, rola, manager_hotel_id)
    VALUES (p_imie, p_nazwisko, LOWER(p_email), p_haslo, p_rola, p_hotel_id);
    RETURN 'SUKCES';
END;
$$ LANGUAGE plpgsql;

-- F5: Zmień hasło
CREATE OR REPLACE FUNCTION zmien_haslo(p_uid INT, p_stare VARCHAR, p_nowe VARCHAR) RETURNS TEXT AS $$
DECLARE v_obecne VARCHAR;
BEGIN
    SELECT haslo INTO v_obecne FROM uzytkownik WHERE id_uzytkownika = p_uid;
    IF v_obecne != p_stare THEN RETURN 'BŁĄD: Złe stare hasło.'; END IF;
    UPDATE uzytkownik SET haslo = p_nowe WHERE id_uzytkownika = p_uid;
    RETURN 'SUKCES: Hasło zmienione.';
END;
$$ LANGUAGE plpgsql;

-- =================================================================
-- 5. AUTOMATYZACJA (TRIGGERY) - PEŁNA WERSJA (8 SZTUK)
-- =================================================================

-- T1: Walidacja Dat
CREATE OR REPLACE FUNCTION waliduj_daty_rezerwacji() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.rezerwacja_do <= NEW.rezerwacja_od THEN RAISE EXCEPTION 'Data wyjazdu musi być późniejsza!'; END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_walidacja_dat BEFORE INSERT OR UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION waliduj_daty_rezerwacji();

-- T2: Auto-Płatność
CREATE OR REPLACE FUNCTION auto_status_rezerwacji() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'oplacona' AND OLD.status != 'oplacona' THEN
        UPDATE rezerwacje SET status = 'oplacona' WHERE id_rezerwacji = NEW.id_rezerwacji;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_auto_oplacenie AFTER UPDATE ON platnosci FOR EACH ROW EXECUTE FUNCTION auto_status_rezerwacji();

-- T3: Sync "Zrealizowana"
CREATE OR REPLACE FUNCTION sync_platnosc_po_rezerwacji() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'zrealizowana' AND OLD.status != 'zrealizowana' THEN
        UPDATE platnosci SET status = 'zaksiegowana' WHERE id_rezerwacji = NEW.id_rezerwacji;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_sync_platnosci AFTER UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION sync_platnosc_po_rezerwacji();

-- T4: Blokada Bezpieczeństwa
CREATE OR REPLACE FUNCTION sprawdz_blokade_klienta() RETURNS TRIGGER AS $$
DECLARE v_zablokowany BOOLEAN;
BEGIN
    SELECT czy_zablokowany INTO v_zablokowany FROM uzytkownik WHERE id_uzytkownika = NEW.id_uzytkownika;
    IF v_zablokowany THEN RAISE EXCEPTION 'BLOKADA: Twoje konto jest zawieszone.'; END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_blokada_bezpieczenstwa BEFORE INSERT ON rezerwacje FOR EACH ROW EXECUTE FUNCTION sprawdz_blokade_klienta();

-- T5: Logi Standardowe
CREATE OR REPLACE FUNCTION loguj_zmiane_statusu() RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO logi_systemowe (id_rezerwacji, stary_status, nowy_status) 
        VALUES (NEW.id_rezerwacji, OLD.status, NEW.status);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_loguj_zmiany AFTER UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION loguj_zmiane_statusu();

-- T6: Logi NoSQL / JSON
CREATE OR REPLACE FUNCTION loguj_zmiane_statusu_json() RETURNS TRIGGER AS $$
DECLARE v_json JSONB;
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        v_json := json_build_object(
            'typ', 'zmiana_statusu', 
            'id_rezerwacji', NEW.id_rezerwacji,
            'szczegoly', json_build_object(
                'stary', OLD.status, 
                'nowy', NEW.status, 
                'uzytkownik_id', NEW.id_uzytkownika
            )
        );
        INSERT INTO logi_nosql (dokument_json) VALUES (v_json);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_loguj_zmiany_json AFTER UPDATE ON rezerwacje FOR EACH ROW EXECUTE FUNCTION loguj_zmiane_statusu_json();

-- T7: Archiwizacja RODO
CREATE OR REPLACE FUNCTION archiwizuj_przed_usunieciem() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO archiwum_uzytkownikow (id_starego_uzytkownika, email, powod) VALUES (OLD.id_uzytkownika, OLD.email, 'Usunięty przez Managera');
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_archiwizacja_usera BEFORE DELETE ON uzytkownik FOR EACH ROW EXECUTE FUNCTION archiwizuj_przed_usunieciem();

-- T8: Ochrona Pokoju
CREATE OR REPLACE FUNCTION chron_pokoj_przed_usunieciem() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM rezerwacje WHERE id_pokoj = OLD.id_pokoj AND rezerwacja_do >= CURRENT_DATE AND status NOT LIKE 'anulowana%') THEN
        RAISE EXCEPTION 'NIE MOŻNA USUNĄĆ: Pokój ma aktywne rezerwacje!';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_ochrona_pokoju BEFORE DELETE ON pokoje FOR EACH ROW EXECUTE FUNCTION chron_pokoj_przed_usunieciem();

-- =================================================================
-- 6. WIDOKI (RAPORTY)
-- =================================================================

CREATE OR REPLACE VIEW raport_przychodow AS
SELECT h.nazwa AS hotel, p.typ_pokoju AS typ, COUNT(r.id_rezerwacji) AS liczba_rezerwacji, SUM(r.cena_ostateczna) AS laczny_zysk
FROM rezerwacje r JOIN pokoje p ON r.id_pokoj = p.id_pokoj JOIN hotele h ON p.hotel_id = h.hotel_id
WHERE r.status != 'anulowana' -- Pokazujemy zyski (również z kar), ukrywamy darmowe anulacje
GROUP BY h.nazwa, p.typ_pokoju ORDER BY laczny_zysk DESC;